// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import "./TrustBankCore.sol";
import "./TrustBankCreditEngine.sol";

// Import the generated Circom verifiers (generated by snarkjs from our circuits)
// These correspond to our TrustBank-specific circuits:
// - TrustBankDeFiTVLVerification -> DeFiTVLVerifier.sol
// - TrustBankLendingHistoryVerification -> LendingHistoryVerifier.sol
// - TrustBankWalletAgeVerification -> WalletAgeVerifier.sol
// import "./verifiers/DeFiTVLVerifier.sol";
// import "./verifiers/LendingHistoryVerifier.sol";
// import "./verifiers/WalletAgeVerifier.sol";

/**
 * @title ZKCreditImportProduction
 * @dev Production-ready ZK reputation verification using Circom circuits
 *
 * This contract integrates with Circom-generated verifiers for privacy-preserving
 * crypto reputation verification. Users can prove DeFi activity, lending history,
 * and wallet age without revealing sensitive financial data.
 */
contract ZKCreditImportProduction is Ownable {
    // Simplified crypto reputation metrics
    enum ReputationMetric {
        DEFI_TVL, // Total Value Locked in DeFi protocols
        LENDING_HISTORY, // Successful loan repayments
        WALLET_AGE // Age of wallet with activity
    }

    struct ReputationThreshold {
        uint256 minValue;
        uint256 trustBoost;
        bool active;
    }

    struct CircomProof {
        uint256[2] a;
        uint256[2][2] b;
        uint256[2] c;
        uint256[] publicSignals;
    }

    struct CryptoVerification {
        address user;
        ReputationMetric metric;
        uint256 threshold;
        uint256 trustBoost;
        uint256 verifiedAt;
        bool active;
        bytes32 nullifier; // Prevents double-spending of proofs
        string ipfsProof;
    }

    // State variables
    TrustBankCore public immutable i_trustBank;
    TrustBankCreditEngine public immutable i_creditEngine;

    // ZK Verifier contracts (would be deployed Circom verifiers)
    // DeFiTVLVerifier public immutable defiTVLVerifier;
    // LendingHistoryVerifier public immutable lendingVerifier;
    // WalletAgeVerifier public immutable walletAgeVerifier;

    // Reputation configurations
    mapping(ReputationMetric => mapping(uint256 => ReputationThreshold))
        public reputationThresholds;
    mapping(address => CryptoVerification[]) public userVerifications;
    mapping(bytes32 => bool) public usedNullifiers; // Prevent proof reuse

    // Constants from previous version
    uint256 public constant VERIFICATION_EXPIRY_TIME = 24 hours;
    uint256 public constant VERIFICATION_VALIDITY_PERIOD = 180 days;

    // DeFi TVL thresholds (in USDC/6 decimals)
    uint256 public constant TVL_TIER_1_THRESHOLD = 10_000e6; // $10k
    uint256 public constant TVL_TIER_2_THRESHOLD = 50_000e6; // $50k
    uint256 public constant TVL_TIER_3_THRESHOLD = 100_000e6; // $100k

    // Trust boost constants
    uint256 public constant TVL_TIER_1_BOOST = 100;
    uint256 public constant TVL_TIER_2_BOOST = 200;
    uint256 public constant TVL_TIER_3_BOOST = 400;
    uint256 public constant LENDING_TIER_1_BOOST = 75;
    uint256 public constant LENDING_TIER_2_BOOST = 150;
    uint256 public constant LENDING_TIER_3_BOOST = 300;
    uint256 public constant WALLET_AGE_TIER_1_BOOST = 50;
    uint256 public constant WALLET_AGE_TIER_2_BOOST = 100;
    uint256 public constant WALLET_AGE_TIER_3_BOOST = 150;

    // Events
    event CryptoReputationVerified(
        address indexed user,
        ReputationMetric indexed metric,
        uint256 threshold,
        uint256 trustBoost
    );
    event TrustBoostApplied(
        address indexed user,
        uint256 boost,
        uint256 newTrustScore
    );

    // Errors
    error InvalidZKProof();
    error NullifierAlreadyUsed();
    error ThresholdNotSupported();
    error VerificationExpired();

    constructor(
        address _vouchPay,
        address _creditEngine
    )
        // address _defiTVLVerifier,
        // address _lendingVerifier,
        // address _walletAgeVerifier
        Ownable(msg.sender)
    {
        i_trustBank = TrustBankCore(_vouchPay);
        i_creditEngine = TrustBankCreditEngine(_creditEngine);

        // Initialize verifier contracts
        // defiTVLVerifier = DeFiTVLVerifier(_defiTVLVerifier);
        // lendingVerifier = LendingHistoryVerifier(_lendingVerifier);
        // walletAgeVerifier = WalletAgeVerifier(_walletAgeVerifier);

        _initializeDefaultThresholds();
    }

    /**
     * @dev Submit ZK proof for crypto reputation verification
     * @param metric Type of reputation metric being proved
     * @param threshold Value threshold being proved
     * @param proof Circom-generated ZK proof
     * @param nullifier Unique nullifier to prevent double-spending
     * @param ipfsProof Optional IPFS hash for additional data
     */
    function submitZKReputationProof(
        ReputationMetric metric,
        uint256 threshold,
        CircomProof calldata proof,
        bytes32 nullifier,
        string calldata ipfsProof
    ) external {
        // Validate threshold is supported
        ReputationThreshold memory thresholdConfig = reputationThresholds[
            metric
        ][threshold];
        if (!thresholdConfig.active) revert ThresholdNotSupported();

        // Prevent nullifier reuse
        if (usedNullifiers[nullifier]) revert NullifierAlreadyUsed();

        // Verify the ZK proof using appropriate Circom verifier
        bool proofValid = false;

        if (metric == ReputationMetric.DEFI_TVL) {
            // Verify DeFi TVL proof
            // proofValid = defiTVLVerifier.verifyProof(proof.a, proof.b, proof.c, proof.publicSignals);

            // For demo, simplified verification:
            proofValid = _verifyDemoProof(proof, threshold);
        } else if (metric == ReputationMetric.LENDING_HISTORY) {
            // Verify lending history proof
            // proofValid = lendingVerifier.verifyProof(proof.a, proof.b, proof.c, proof.publicSignals);

            proofValid = _verifyDemoProof(proof, threshold);
        } else if (metric == ReputationMetric.WALLET_AGE) {
            // Verify wallet age proof
            // proofValid = walletAgeVerifier.verifyProof(proof.a, proof.b, proof.c, proof.publicSignals);

            proofValid = _verifyDemoProof(proof, threshold);
        }

        if (!proofValid) revert InvalidZKProof();

        // Check proof timestamp from public signals
        if (proof.publicSignals.length > 1) {
            uint256 proofTimestamp = proof.publicSignals[1];
            if (block.timestamp - proofTimestamp > VERIFICATION_EXPIRY_TIME) {
                revert VerificationExpired();
            }
        }

        // Mark nullifier as used
        usedNullifiers[nullifier] = true;

        // Record verification
        userVerifications[msg.sender].push(
            CryptoVerification({
                user: msg.sender,
                metric: metric,
                threshold: threshold,
                trustBoost: thresholdConfig.trustBoost,
                verifiedAt: block.timestamp,
                active: true,
                nullifier: nullifier,
                ipfsProof: ipfsProof
            })
        );

        // Apply trust boost
        _applyTrustBoost(msg.sender, thresholdConfig.trustBoost);

        emit CryptoReputationVerified(
            msg.sender,
            metric,
            threshold,
            thresholdConfig.trustBoost
        );
    }

    /**
     * @dev Simplified proof verification for demo (replace with real Circom verifiers)
     */
    function _verifyDemoProof(
        CircomProof calldata proof,
        uint256 threshold
    ) internal pure returns (bool) {
        // Basic sanity checks
        if (proof.a[0] == 0 || proof.a[1] == 0) return false;
        if (proof.b[0][0] == 0 || proof.b[0][1] == 0) return false;
        if (proof.c[0] == 0 || proof.c[1] == 0) return false;

        // Check that public signals contain the threshold
        if (proof.publicSignals.length == 0) return false;
        if (proof.publicSignals[0] != threshold) return false;

        return true;
    }

    /**
     * @dev Get total crypto reputation boost for a user
     */
    function getUserCryptoBoost(address user) external view returns (uint256) {
        uint256 totalBoost = 0;
        CryptoVerification[] memory verifications = userVerifications[user];

        for (uint256 i = 0; i < verifications.length; i++) {
            if (
                verifications[i].active &&
                block.timestamp - verifications[i].verifiedAt <
                VERIFICATION_VALIDITY_PERIOD
            ) {
                totalBoost += verifications[i].trustBoost;
            }
        }

        return totalBoost;
    }

    /**
     * @dev Apply trust boost to user's score
     */
    function _applyTrustBoost(address user, uint256 boost) internal {
        i_trustBank.applyCreditBoost(user, boost);
        uint256 newScore = i_trustBank.getTotalTrustScore(user);
        emit TrustBoostApplied(user, boost, newScore);
    }

    /**
     * @dev Initialize default thresholds (same as before)
     */
    function _initializeDefaultThresholds() internal {
        // DeFi TVL thresholds
        reputationThresholds[ReputationMetric.DEFI_TVL][
            TVL_TIER_1_THRESHOLD
        ] = ReputationThreshold(TVL_TIER_1_THRESHOLD, TVL_TIER_1_BOOST, true);
        reputationThresholds[ReputationMetric.DEFI_TVL][
            TVL_TIER_2_THRESHOLD
        ] = ReputationThreshold(TVL_TIER_2_THRESHOLD, TVL_TIER_2_BOOST, true);
        reputationThresholds[ReputationMetric.DEFI_TVL][
            TVL_TIER_3_THRESHOLD
        ] = ReputationThreshold(TVL_TIER_3_THRESHOLD, TVL_TIER_3_BOOST, true);

        // Add other thresholds...
    }

    /**
     * PRODUCTION ZK INTEGRATION NOTES:
     *
     * 1. CIRCOM SETUP:
     *    - Compile circuits: circom circuit.circom --r1cs --wasm --sym
     *    - Trusted setup: snarkjs groth16 setup circuit.r1cs ptau circuit.zkey
     *    - Export verifier: snarkjs zkey export solidityverifier circuit.zkey verifier.sol
     *
     * 2. DATA SOURCES:
     *    - Integrate with Chainlink oracles for DeFi TVL data
     *    - Use The Graph for lending history verification
     *    - Verify wallet age through block explorers
     *
     * 3. PRIVACY GUARANTEES:
     *    - Zero-knowledge: No sensitive data revealed
     *    - Unlinkability: Different proofs can't be linked to same user
     *    - Non-reusability: Nullifiers prevent proof replay
     *
     * 4. SECURITY CONSIDERATIONS:
     *    - Trusted setup ceremony for production
     *    - Regular verifier contract audits
     *    - Circuit constraint verification
     */
}
